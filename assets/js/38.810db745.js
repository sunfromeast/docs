(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{235:function(v,_,a){"use strict";a.r(_);var e=a(0),t=Object(e.a)({},function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口","aria-hidden":"true"}},[v._v("#")]),v._v(" 接口")]),v._v(" "),a("h2",{attrs:{id:"接口特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口特性","aria-hidden":"true"}},[v._v("#")]),v._v(" 接口特性")]),v._v(" "),a("blockquote",[a("ol",[a("li",[v._v("接口使用"),a("code",[v._v("interface")]),v._v("修饰。接口不是类，不能使用"),a("code",[v._v("new")]),v._v("实例化接口，但是可以声明接口变量，接受子类对象。")]),v._v(" "),a("li",[v._v("接口中所有的方法都是"),a("code",[v._v("public")]),v._v("修饰的，默认可以不写。再"),a("code",[v._v("java8")]),v._v("之前接口中不能实现方法，但是在"),a("code",[v._v("java8")]),v._v("之后，可以提供简单方法。")]),v._v(" "),a("li",[v._v("接口中不能声明变量，但是可以声明常量，修饰符默认是"),a("code",[v._v("public static final")]),v._v("，使用时默认可以不写。")])]),v._v(" "),a("p",[a("code",[v._v("java8")]),v._v("接口增强：")]),v._v(" "),a("ol",[a("li",[v._v("接口中可以添加"),a("code",[v._v("default")]),v._v("关键字修饰的非抽象方法，即默认方法。")]),v._v(" "),a("li",[v._v("接口中可以声明静态方法，并且可以实现。")])])]),v._v(" "),a("h2",{attrs:{id:"接口与抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口与抽象类","aria-hidden":"true"}},[v._v("#")]),v._v(" 接口与抽象类")]),v._v(" "),a("p",[v._v("抽象类的特点：")]),v._v(" "),a("blockquote",[a("ol",[a("li",[v._v("抽象类使用"),a("code",[v._v("abstract")]),v._v("关键字修饰。因为抽象类中可能包含未实现的抽象方法，所以，它不能被实例化。")]),v._v(" "),a("li",[v._v("抽象类中如果有抽象方法，则抽象方法需要使用"),a("code",[v._v("public 或者 protected")]),v._v("修饰，缺省情况下是"),a("code",[v._v("public")]),v._v("。")]),v._v(" "),a("li",[v._v("抽象类中可以声明普通变量。")])])]),v._v(" "),a("p",[v._v("接口与抽象类之间的联系和区别：")]),v._v(" "),a("blockquote",[a("p",[v._v("相同点：")]),v._v(" "),a("ol",[a("li",[v._v("都不能实例化")])]),v._v(" "),a("p",[v._v("不同点：")]),v._v(" "),a("ol",[a("li",[v._v("一个类可以实现多个接口，但是只能继承一个抽象类。")]),v._v(" "),a("li",[v._v("变量：接口中只能存在常量，不能声明变量。抽象类中可以声明变量。\n"),a("ol",[a("li",[v._v("方法：接口中在"),a("code",[v._v("java8")]),v._v("之前全部是未实现的抽象方法，在"),a("code",[v._v("java8")]),v._v("之后可以包含实现的方法。抽象类中的方法可以有实现细节。另外，接口中"),a("code",[v._v("java")]),v._v("之前不能有静态方法或者静态代码块，"),a("code",[v._v("java8")]),v._v("接口增强后没有限制。")])])])])]),v._v(" "),a("h2",{attrs:{id:"解决默认方法冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决默认方法冲突","aria-hidden":"true"}},[v._v("#")]),v._v(" 解决默认方法冲突")]),v._v(" "),a("p",[v._v("如果在一个接口中将一个方法定义为默认方法，在另外一个超类或者接口中定义了同样的方法，那么子类继承或者实现了这些类和接口后，发生了冲突怎么办？java处理冲突的规则如下：")]),v._v(" "),a("blockquote",[a("ol",[a("li",[v._v("超类优先。超类提供了一个具体方法，同名并且具有相同参数的默认方法会被忽略。好处是：确保兼容性。")]),v._v(" "),a("li",[v._v("接口冲突。这个冲突的方法必须重写，由程序员解决冲突。")])]),v._v(" "),a("p",[v._v("重要提醒：")]),v._v(" "),a("ol",[a("li",[v._v("千万不要让默认方法重写"),a("code",[v._v("Object")]),v._v("类中的方法，这是没有意义的，因为，每个类都继承了"),a("code",[v._v("Object")]),v._v("类，而方法冲突时“超类优先”的原则，会使得接口中重写的方法被忽略。")])])])])},[],!1,null,null,null);_.default=t.exports}}]);