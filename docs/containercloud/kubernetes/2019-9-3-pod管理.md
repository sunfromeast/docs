## pod资源对象

pod资源对象用于运行单个容器化的应用，此应用称为pod对象的主容器，当然，pod也能同时容纳多个容器，额外的容器一般的工作模型有一下几种：

### Sidecar模型

这个模型是为pod中的主容器提供协同的辅助应用容器。例如：主应用容器中的日志使用agent收集到日志服务器中，agent作为辅助应用容器。

### Ambassador模型

这个模型是为远程服务在pod中创建一个本地代理，pod中的主容器通过代理容器访问远程服务。例如：主应用容器访问远程一主多从模型的远程Redis应用时，可以在当前容器中为远程Redis创建一个本地代理Ambassador container，主应用容器直接通过localhost接口访问Ambassador接口即可，这样，Redis有修改的话，不用修改主容器，只需要修改这个代理容器即可。

### Adapter模型

一般用于不兼容时做适配，如：容器日志格式化输出。

## pod的生命周期

### 几个状态

pod在生命周期中有一下几个状态：

| 状态      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| pending   | API Server创建pod资源对象已经存入etcd，尚未调度完成或正在下载镜像 |
| Running   | pod已被调度，所有容器都已被kubelet创建完成                   |
| Successed | pod中所有容器都已经终止并不会重启                            |
| Failed    | 所有容器都已终止，且至少一个非正常终止（返回非0值）          |
| Unknown   | APIServer无法获取pod的状态信息，通常是无法和工作节点上的kubelet通信所致 |

### pod创建过程

1. 客户端（kubectl等）提交pod spec给APIServer。
2. APIServer尝试将pod对象的相关信息写入etcd，写入操作完成，APIServer会返回信息给客户端。
3. APIServer将会一直反映etcd中的状态变化
   1. kubernetes所有组件均使用“watch”机制跟踪检查APIServer上的相关变动。
   2. kube-scheduler的“watcher”察觉到APIServer创建了一个新的pod，还没有绑定到任何节点，然后，它就为pod挑选了一个工作节点并将信息更新至APIServer。
   3. APIServer将调度结果更新至etcd，同时，它会反映出pod对象的调度结果。
   4. pod所在节点上的kubelet尝试在当前节点调用docker启动容器，并将容器的启动状态返回给APIServer。
   5. APIServer将pod状态信息存入etcd系统中，将存储结果发送到相关的kubelet。