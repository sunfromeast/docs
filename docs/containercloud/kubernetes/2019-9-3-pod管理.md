## pod的yaml文件定义

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: two-containers
spec:
  restartPolicy: Never
  volumes:
  - name: shared-data
    hostPath:      
      path: /data
  containers:
  - name: nginx-container
    image: nginx
    volumeMounts:
    - name: shared-data
      mountPath: /usr/share/nginx/html
  - name: debian-container
    image: debian
    volumeMounts:
    - name: shared-data
      mountPath: /pod-data
    command: ["/bin/sh"]
    args: ["-c", "echo Hello from the debian container > /pod-data/index.html"]

```

pod中的几个重要字段：除了传统的apiVersion、kind、metadta、spec、status外

- `.spec.hostAliases`：定义pod中hosts（/etc/hosts）内容

  ```markdown
  apiVersion: v1
  kind: Pod
  ...
  spec:
    hostAliases:
    - ip: "10.1.2.3"
      hostnames:
      - "foo.remote"
      - "bar.remote"
  ...
  ```

- `.spec.containers.lifecycle`：定义容器生命周期钩子，在容器生命周期中，当容器的状态发生改变时，将触发一系列钩子。

  ```markdown
  apiVersion: v1
  kind: Pod
  metadata:
    name: lifecycle-demo
  spec:
    containers:
    - name: lifecycle-demo-container
      image: nginx
      lifecycle:
        postStart:
          exec:
            command: ["/bin/sh", "-c", "echo Hello from the postStart handler > /usr/share/message"]
        preStop:
          exec:
            command: ["/usr/sbin/nginx","-s","quit"]
  
  ```

  > - postStart：定义容器启动后立即执行的动作。不过注意，这个动作和容器的ENTRYPOINT并不是同步的，换句话说，它不保证顺序，postStart启动时，ENTRYPOINT可能还没有结束。
  > - preStop：定义容器杀死前执行的动作。preStop和杀死容器是同步阻塞的，也就是说，preStop没有执行完成，那么杀死容器就不能执行。

## pod的原理

- <font color=red>pod的一个重要事实：它只是一个逻辑概念。</font>

  > kubernetes真正处理的，还是宿主机上的Linux容器的namespace和cgroups。并不存在所谓的pod边界或者隔离环境。pod实际上是一组共享了资源的容器。具体的说，pod中的所有容器共享了同一个Network Namespace和相同的volume。

- <font color=red>既然是共享Network Space和volume，那么是A共享B、还是B共享A，还是其他方式呢？</font>

  > 假如，有包含A和B两个容器的pod，如果容器A共享容器B的资源，那么：
  >
  > ```markdown
  > docker run --net=B --volumes-from=B --name=A image-A
  > ```
  >
  > 如果真是这样的话，需要容器B在容器A之前启动，A和B就不是对等关系，而变成拓扑关系了。所以，pod的实现需要一个中间容器。

- <font color=red>实现pod的中间容器：</font>

  > 实现pod的中间容器，也叫Infra容器（镜像是`k8s.gcr.io/pause`，镜像很小，容器处于暂停状态）。一个pod中Infra容器是第一个被启动的容器。用户定义的容器，通过Join Network Namespace，与Infra容器关联在一起。
  >
  > ![](./images/pod-infra.png)

## pod资源对象

pod资源对象用于运行单个容器化的应用，此应用称为pod对象的主容器，当然，pod也能同时容纳多个容器，额外的容器一般的工作模型有一下几种：

### Sidecar模型

这个模型是为pod中的主容器提供协同的辅助应用容器。例如：主应用容器中的日志使用agent收集到日志服务器中，agent作为辅助应用容器。

### Ambassador模型

这个模型是为远程服务在pod中创建一个本地代理，pod中的主容器通过代理容器访问远程服务。例如：主应用容器访问远程一主多从模型的远程Redis应用时，可以在当前容器中为远程Redis创建一个本地代理Ambassador container，主应用容器直接通过localhost接口访问Ambassador接口即可，这样，Redis有修改的话，不用修改主容器，只需要修改这个代理容器即可。

### Adapter模型

一般用于不兼容时做适配，如：容器日志格式化输出。

## pod的生命周期

### 几个状态

pod在生命周期中有一下几个状态：

| 状态      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| pending   | API Server创建pod资源对象已经存入etcd，尚未调度完成或正在下载镜像 |
| Running   | pod已被调度，所有容器都已被kubelet创建完成                   |
| Successed | pod中所有容器都已经终止并不会重启                            |
| Failed    | 所有容器都已终止，且至少一个非正常终止（返回非0值）          |
| Unknown   | APIServer无法获取pod的状态信息，通常是无法和工作节点上的kubelet通信所致 |

### pod创建过程

1. 客户端（kubectl等）提交pod spec给APIServer。
2. APIServer尝试将pod对象的相关信息写入etcd，写入操作完成，APIServer会返回信息给客户端。
3. APIServer将会一直反映etcd中的状态变化
   1. kubernetes所有组件均使用“watch”机制跟踪检查APIServer上的相关变动。
   2. kube-scheduler的“watcher”察觉到APIServer创建了一个新的pod，还没有绑定到任何节点，然后，它就为pod挑选了一个工作节点并将信息更新至APIServer。
   3. APIServer将调度结果更新至etcd，同时，它会反映出pod对象的调度结果。
   4. pod所在节点上的kubelet尝试在当前节点调用docker启动容器，并将容器的启动状态返回给APIServer。
   5. APIServer将pod状态信息存入etcd系统中，将存储结果发送到相关的kubelet。