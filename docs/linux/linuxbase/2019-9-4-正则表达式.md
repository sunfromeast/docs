## 正则表达式基础

### 1. grep

grep：全称globally search a regular expression and print，以正则表达式全局搜索和打印。支持对来自标准输入、管道输入、以及文本文件的内容进行正则表达式搜索。

```properties
#1 标准输入方式
//彩色标注匹配到的内容
$ grep --color 'haha'  

#2 管道输入方式
$ ls | grep --color 'Do'

#3 文件方式
$ grep --color 'haha' /test

注意：grep只能按行依次匹配，不能实现跨换行符的多行匹配。
```

### 2. 元字符、文本字符、转义字符

一个完整的正则表达式由：元字符和文本字符组成。

元字符：如“^，$，.，*”。分别代表：匹配一行开始，匹配一行结束、匹配任意一个字符、匹配前面的字符0次或多次。

文本字符：普通文本

转义字符：如果匹配的内容是字符本身，需要用到转义字符。

**注意：**书写正则表达式时，单引号可以防止空格被shell当成参数分隔符问题，但其本身无法出现单引号。双引号会出现双重转义，所以，使用\x27代表单引号。

### 3. 语法规则

#### 3.1 定位符

| 定位符 | 说明                 | 实例   | 匹配结果        |
| ------ | -------------------- | ------ | --------------- |
| ^      | 匹配字符串开始的位置 | ^Hello | ==Hello== World |
| $      | 匹配字符串结束位置   | World$ | Hello ==World== |

匹配空行：^$

#### 3.2 选择符

选择符：|；理解为：或

#### 3.3 范围字符

| 实例   | 说明                    | 匹配结果                 |
| ------ | ----------------------- | ------------------------ |
| [abc]  | 匹配a,b,c三个字符       | ==a==pple,==ba==nan==a== |
| [^abc] | 匹配除a，b，c以外的字符 |                          |
| [a-z]  | 匹配a-z范围字符         |                          |

#### 3.4 点字符和限定符

| 字符  | 说明                            | 示例       | 结果             |
| ----- | ------------------------------- | ---------- | ---------------- |
| .     | 匹配任意字符                    | s.t        | sat，sit，set    |
| ？    | 匹配前一个字符0次或一次         | s?t        | st，sst          |
| *     | 匹配前一个字符0次或多次         | s*t        | st，ssssst       |
| +     | 匹配前面的字符一次或多次        | s+t        | sst，sssst       |
| {n}   | 匹配前面的字符n次               | go{2}gle   | google           |
| {n,}  | 匹配前面的字符最少n次           | go{2,}gle  | google，goooogle |
| {n,m} | p匹配前面的字符最少n次，最多mci | go{1,2}gle | gogle，google    |

点字符和限定符连用，可以匹配指定数量范围的任意字符

#### 3.5 贪婪匹配和惰性匹配

| 匹配方式 | 实例  | 说明                                                     | 结果                 |
| -------- | ----- | -------------------------------------------------------- | -------------------- |
| 贪婪     | a.*b  | 最先出现的a和最后出现的b，即：a和b之间可以有任意多个字符 | ==adsfabdlsfb==fsldf |
| 惰性     | a.*?b | 最先出现的a和最先出现的b                                 | ==acsfb==fsdf==ab==c |

#### 3.6 小括号

作用：改变作用范围，分组

改变作用范围：

| 示例              | 说明     | 匹配结果 |
| ----------------- | -------- | -------- |
| （third\|four）th | 改变范围 |          |

分组：

| 示例      | 说明   | 匹配结果         |
| --------- | ------ | ---------------- |
| app{2}    | 分组前 | ==appp==apaapapa |
| （app){2} | 分组后 | ==appapp==papapa |

#### 3.7 反斜线

| 字符 | 说明                                 |
| ---- | ------------------------------------ |
| \d   | 任意十进制数字，相当于[0-9]          |
| \D   | 任意一个非十进制数字                 |
| \w   | 任意一个单词字符，相当于[a-zA-Z0-9]  |
| \W   | 任意一个非单词字符                   |
| \s   | 任意一个空白字符（空格、水平制表符） |
| \S   | 任意一个非空白字符                   |
| \b   | 单词分界符                           |
| \B   | 非单词分界符                         |
| \x   | 16进制数字                           |

### 4. 应用案例

#### 4.1 验证文件扩展名

```properties
# 匹配任意html，css，jpg文件
# .*?表示惰性匹配
^.*?\.(html|css|jpg)  
```

#### 4.2 验证IP地址

```properties
# IP范围：0.0.0.0~255.255.255.255
# 1 将IP地址拆分成：
# 0-99：[1-9]?\d
# 100-199：1\d{2}
# 200-249：2[0-4]\d
# 250-255：25[0-5]
合并之后：
0-255：[1-9]?\d|1\d{2}|2([0-4]\d|5[0-5])

# 2 验证分割符
假设上面0-255表示为：A，则：
^(A\.){3}A$
```

## sed工具

管道命令，行级数据处理工具，用于将数据进行替换、删除、新增、选取特定行。

```mariadb
$ sed [-nefri] [动作]
```

> 其中：
>
> -n：安静模式，加上-n，只有经过处理的行才会被列出。
>
> -e：直接在命令行模式进行sed的动作编辑
>
> -f：-f filename，将sed动作写入文件
>
> -r：sed动作支持扩展型正则语法
>
> -i：直接修改读取的文件内容，不是屏幕输出
>
> 动作说明：n1,n2 function
>
> n1,n2：指明行号
>
> function：
>
> a：新增，后接字符串，该字符串会出现在当前行的下一行。
>
> c：替换，后接字符串，
>
> d：删除，后不接参数
>
> i：插入，后接字符串，该字符串会在当前行的上一行出现
>
> p：打印，将选择的数据打印出来，通常p会与参数sed -n一起运行
>
> s：替换，这个动作可以搭配正则表达式

使用示例：

```markdown
# 删除，删除/etc/passwd的2-5行
$ nl /etc/passwd | sed '2,5d'

# 新增， 在第二行后面添加drink tea(出现在第三行)
$ nl /etc/passwd | sed '2a drink tea'

# 插入，在第二行前面插入drink tea
$ nl /etc/passed | sed '2i drink tea'

# 行级替换，2-5内容替换为hello world
$ nl /etc/passwd | sed '2,5c hello world'

# 打印，列出2-5行数据,-n和p是一起用的
$ nl /etc/passwd | sed -n '2,5p'

# 部分数据的查找和替换
$ sed 's/要替换的字符串/新字符串/g'
```

## awk工具

相比于行级数据处理工具sed，awk用于将一行分成数个字段来处理。因此，其适合小型的数据处理。

```markdown
$ awk '条件类型1{动作1} 条件类型2{动作2} ...' filename 
```

> awk可以读取文件，也可以读取管道中的标准输出。awk主要处理每一行字段内的数据，默认的字段的分割符为空格键或tab键。

如果要获取当前处理了几行、几列，需要内置变量：

| 变量名 | 说明                         |
| ------ | ---------------------------- |
| NF     | 每行总字段数                 |
| NR     | 目前处理的是第几行数据       |
| FS     | 目前的分隔符，默认的是空格键 |

逻辑运算符：>, >= ,<, <=, ==, !=

```markdown
# last取前5行
$ last -n 5
root     pts/0        61.183.81.136    Wed Sep  4 19:18   still logged in   
root     pts/2        61.183.81.136    Wed Sep  4 16:10 - 19:54  (03:43)    
root     pts/1        61.183.81.129    Wed Sep  4 15:53 - 17:15  (01:21)    
root     pts/1        61.183.81.129    Wed Sep  4 15:49 - 15:49  (00:00)    
root     pts/0        61.183.81.136    Wed Sep  4 14:26 - 17:23  (02:57)    

# 取出用户名和ip
$ last -n 5 | awk '{print $1 "\t" $3}'
root	61.183.81.136
root	61.183.81.136
root	61.183.81.129
root	61.183.81.129
root	61.183.81.136

# 测试NR和NF
$ last -n 5 | awk '{print $1 "\t lines:" NR "\t colums:" NF}'
root	 lines:1	 colums:10
root	 lines:2	 colums:10
root	 lines:3	 colums:10
root	 lines:4	 colums:10
root	 lines:5	 colums:10

# 输出第三列小于10以下的数据
$ cat /etc/passwd | awk '{FS=":"} $3 < 10{print $1 "\t" $3}'
root:x:0:0:root:/root:/bin/bash	
bin	1
daemon	2
adm	3
lp	4
sync	5
shutdown	6
halt	7
mail	8
//发现第一行没有正确显示，原因：读入第一行的时候，变量还是默认以空格分隔，可以利用BEGIN关键字

# 承上例
$ cat /etc/passwd | awk 'BEGIN {FS=":"} $3<10{print $1 "\t" $3}'
root	0
bin	1
daemon	2
adm	3
lp	4
sync	5
shutdown	6
halt	7
mail	8
```

> 注意几点：
>
> 1. {}内多个命令辅助时，用分号隔开
> 2. 在awk中，变量可以直接引用，不用加分号